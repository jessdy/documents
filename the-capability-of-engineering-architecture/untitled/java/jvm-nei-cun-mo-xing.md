---
description: Java内存模型，简称JMM
---

# JVM内存模型

在计算机中，cpu和内存的交互最为频繁，相比内存，磁盘读写太慢，内存相当于高速的缓冲区。

但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种情况。现在cpu和内存的交互大致如下。

![CPU/&#x9AD8;&#x901F;&#x7F13;&#x5B58;/&#x5185;&#x5B58;](../../../.gitbook/assets/image%20%2817%29.png)

cpu上加入了高速缓存这样做解决了处理器和内存的矛盾\(一快一慢\)，但是引来的新的问题 - **缓存一致性**

在多核cpu中，每个处理器都有各自的高速缓存\(L1,L2,L3\)，而主内存确只有一个 。所以上图就变成了如下：

![&#x591A;&#x6838;CPU/&#x9AD8;&#x901F;&#x7F13;&#x5B58;/&#x5185;&#x5B58;](../../../.gitbook/assets/image%20%2813%29.png)

内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行  
JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行  
不同的JVM对于内存的划分方式和管理机制存在着部分差异。

JVM内存分为五大模块

![JVM&#x5185;&#x5B58;&#x7ED3;&#x6784;](../../../.gitbook/assets/image%20%288%29.png)

![JVM&#x5185;&#x5B58;&#x7ED3;&#x6784;2](../../../.gitbook/assets/image%20%2811%29.png)

## Program Counter Register \(程序计数寄存器\)

#### 1. 定义

程序计数器是一块较小的内存空间，可看作当前线程正在执行的字节码的行号指示器  
如果当前线程正在执行的是

* Java方法 计数器记录的就是当前线程正在执行的字节码指令的地址
* 本地方法 那么程序计数器值为undefined

#### 2. 作用

程序计数器有两个作用

* 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
* 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

#### 3. 特点

一块较小的内存空间 线程私有。每条线程都有一个独立的程序计数器。 是唯一一个不会出现OOM的内存区域。 生命周期随着线程的创建而创建，随着线程的结束而死亡。

## Java虚拟机栈\(JVM Stack\)

#### 1. 定义

JVM是基于栈结构的运行环境  
栈结构移植性更好，可控性更强  
JVM中的虚拟机栈是描述Java方法执行的内存区域，它是线程私有的

栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，就是栈帧从入栈到出栈的过程  
在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧  
正在执行的方法称为当前方法  
栈帧是方法运行的基本结构

在执行引擎运行时，所有指令都只能针对当前栈帧进行操作  
StackOverflowError表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中

![&#x865A;&#x62DF;&#x673A;&#x6808;&#x64CD;&#x4F5C;&#x793A;&#x610F;&#x56FE;](../../../.gitbook/assets/image%20%2816%29.png)

虚拟机栈通过压/出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上  
在执行的过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定  
栈帧在整个JVM体系中的地位颇高,包括局部变量表、操作栈、动态连接、方法返回地址等

* 局部变量表 存放方法参数和局部变量 相对于类属性变量的准备阶段和初始化阶段来说，局部变量没有准备阶段，必须显式初始化 如果是非静态方法，则在index\[0\]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量 字节码指令中的STORE指令就是将操作栈中计算完成的局部变量写回局部变量表的存储空间内
* 操作栈 操作栈是一个初始状态为空的桶式结构栈 在方法执行过程中，会有各种指令往栈中写入和提取信息 JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈 字节码指令集的定义都是基于栈类型的,栈的深度在方法元信息的stack属性中
* 动态连接 每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接
* 方法返回地址 方法执行时有两种退出情况
  * 正常退出
  * 异常退出

无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧

#### 2. 特点

局部变量表的创建是在方法被执行的时候,随着栈帧的创建而创建.  
而且表的大小在编译期就确定,在创建的时候只需分配事先规定好的大小即可.  
在方法运行过程中,表的大小不会改变

Java虚拟机栈会出现两种异常

* **StackOverFlowError** 若Java虚拟机栈的内存大小不允许动态扩展,那么当线程请求的栈深度大于虚拟机允许的最大深度时\(但内存空间可能还有很多\),就抛出此异常
* **OutOfMemoryError** 若Java虚拟机栈的内存大小允许动态扩展,且当线程请求栈时内存用完了,无法再动态扩展了,此时抛出OutOfMemoryError异常

Java虚拟机栈也是线程私有的,每个线程都有各自的Java虚拟机栈,而且随着线程的创建而创建,随着线程的死亡而死亡。

## 本地方法栈\(Native Method Stack\)

本地方法栈和Java虚拟机栈实现的功能与抛出异常几乎相同  
只不过虚拟机栈是为虚拟机执行Java方法\(也就是字节码\)服务,本地方法区则为虚拟机使用到的Native方法服务.

在JVM内存布局中，也是线程对象私有的,但是虚拟机栈“主内”，而本地方法栈“主外”  
这个“内外”是针对JVM来说的，本地方法栈为Native方法服务  
线程开始调用本地方法时，会进入一个不再受JVM约束的世界  
本地方法可以通过JNI\(Java Native Interface\)来访问虚拟机运行时的数据区，甚至可以调用寄存器,具有和JVM相同的能力和权限  
当大量本地方法出现时,势必会削弱JVM对系统的控制力,因为它的出错信息都比较黑盒.  
对于内存不足的情况，本地方法栈还是会拋出native heap OutOfMemory

最著名的本地方法应该是System.currentTimeMillis\(\)，JNI 使Java深度使用OS的特性功能，复用非Java代码  
但是在项目过程中，如果大量使用其他语言来实现JNI,就会丧失跨平台特性，威胁到程序运行的稳定性  
假如需要与本地代码交互，就可以用中间标准框架进行解耦，这样即使本地方法崩溃也不至于影响到JVM的稳定  
当然，如果要求极高的执行效率、偏底层的跨进程操作等，可以考虑设计为JNI调用方式

## Java堆\(Java Heap\)

堆存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用。

堆被划分成两个不同的区域：**新生代 \( Young \)**、**老年代 \( Old \)**。新生代 \( Young \) 又被划分为三个区域：**Eden**、**From Survivor**、**To Survivor**。

![Java&#x5806;&#x5185;&#x5B58;&#x5206;&#x5E03;](../../../.gitbook/assets/image.png)

绝大部分对象在Eden区生成，当Eden区装填满的时候，会触发Young GC。垃圾回收的时候，在Eden区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到Survivor区。

Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC \( 或称为 Major GC \)。

当对象在 Eden \( 包括一个 Survivor 区域，这里假设是 from 区域 \) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳\(上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 \)，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 \( 即 to 区域 \) 中，然后清理所使用过的 Eden 以及 Survivor 区域 \( 即 from 区域 \)，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 \( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 \)，这些对象就会成为老年代。 

![&#x5BF9;&#x8C61;&#x751F;&#x547D;&#x5468;&#x671F;](../../../.gitbook/assets/image%20%281%29.png)

## 方法区

#### 1. 定义

Java虚拟机规范中定义方法区是堆的一个逻辑部分，但是别名Non-Heap\(非堆\)，以与Java堆区分。方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

#### 2. 特点

* 线程共享 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
* 永久代 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为永久代。
* 内存回收效率低 Java虚拟机规范对方法区的要求比较宽松,可以不实现垃圾收集. 方法区中的信息一般需要长期存在,回收一遍内存之后可能只有少量信息无效. 对方法区的内存回收的主要目标是:**对常量池的回收和对类型的卸载**

和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。

当方法区内存空间无法满足内存分配需求时,将抛出OutOfMemoryError异常。

## 直接内存\(Direct Memory\)

直接内存不是虚拟机运行时数据区的一部分,也不是JVM规范中定义的内存区域,但在JVM的实际运行过程中会频繁地使用这块区域.而且也会抛OOM

在JDK 1.4中加入了NIO\(New Input／Output\)类,引入了一种基于管道和缓冲区的IO方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在堆里的DirectByteBuffer对象作为这块内存的引用来操作堆外内存中的数据.  
这样能在一些场景中显著提升性能,因为避免了在Java堆和Native堆中来回复制数据.

## Metaspace \(元空间\)

在JDK8，元空间的前身Perm区已经被淘汰，在JDK7及之前的版本中，只有Hotspot才有Perm区\(永久代\),它在启动时固定大小，很难进行调优,并且Full GC时会移动类元信息。

JDK8使用元空间替换永久代。区别于永久代，元空间在本地内存中分配。也就是说，只要本地内存足够，它不会出现像永久代中java.lang.OutOfMemoryError: PermGen space。默认情况下，“元空间”的大小可以动态调整，或者使用新参数MaxMetaspaceSize来限制本地内存分配给类元数据的大小。

最后,从线程共享的角度来看

* 堆和元空间是所有线程共享的
* 虚拟机栈、本地方法栈、程序计数器是线程内部私有的

从这个角度看一下Java内存结构  


![](../../../.gitbook/assets/image%20%283%29.png)

